# Multilevel scheduler

Assignment for INF1019 - Computer Systems in Pontifical Catholic University of Rio de Janeiro (PUC-Rio)

## Group members

[Julio Neuman Kessel](https://github.com/JNKessel)

[Pedro Sousa Meireles](https://github.com/psmeireles)

## Usage

Open two terminals. In the first one, type the commands `gcc -o escalonador escalonador.c fila.c" e ent√£o "./escalonador`.

In the second, enter `gcc -o interpretador interpretador.c` and then `./interpretador`.

In the second terminal execute "exec [program name] ([burst times])" to run a program that requires the passed burst times. The result
of the programs typed in the interpreter will be displayed in the first terminal.

To terminate the program enter the command ctrl + c in both terminals.
  
## How it works
The scheduler must be run first because it writes its pid into shared memory.

The interpreter reads this region of memory and saves the pid of the scheduler so that it can send a signal to the scheduler when
there is a new process ready to run.

The interpreter works with a loop that reads commands from the terminal and creates a new process with the
received parameters. This process is stored in shared memory, which will be later accessed
by the scheduler. The commands received by the interpreter are of the form
"exec [program name] ([burst times])", where burst times are separated by commas.

After saving the information about the new process in the shared memory, the interpreter notifies the
the scheduler so that it knows that there is a new process to be scheduled.


The scheduler, when started, writes its pid in the shared memory region that will be read
by the interpreter. It creates the levels of the scheduler, which are represented by queues. The rest of the
program is a loop that runs RoundRobin on each queue. If there is no process in any of the queues, 
the scheduler sleeps until it receives a process from the interpreter.

Before starting RoundRobin, it checks to see if there is any process in a higher priority queue than the current one, so that
it stops running RoundRobin at the current level and runs at the higher priority queue. That
verification is also made after the execution of each program.

The execution of a program can be split into two cases:
1. A new program:
If the program to be run has not yet undergone any execution burst, a child process 
must be created for it to run.
2. A program in the "ready" state:
If a program is "ready" it means that the process has already been created. Then, just send
a signal for it to resume execution.


## Signals

Six signals were used in the scheduler.
* SIGUSR1

  This signal is received every time a new process is received by the interpreter.
  
  Its handler allocates the memory required for the new process and copies the data from the shared memory,
finally pushing it to the higher priority level of the scheduler.

* SIGUSR2
  This signal is received when a running process waits for I / O.

  Its handler stops running the process. It modifies the field corresponding to the next queue the process will go to and 
inserts it into a queue for I / O. At the same time it creates a child process that will serve as an alarm.
  
  The alarm waits 3 seconds and sends SIGALRM to the scheduler, notifying it that the process is ready to
run again. It modifies the value of a flag so that the ExecutarProcesso function can modify
the state of the process and return a value corresponding to the event.

* SIGALRM
  This signal is received when the 3-second wait for I / O of a process ends.
  
  Its handler removes a process from the I / O queue, modifies its state to "ready" and moves the
process to the correct queue.

* SIGCHLD
  This signal is received when a child process is interrupted or terminated.
  
  Its handler identifies whether this signal was generated by an interruption or by the termination of a child process.
If it is due to an interruption, it does nothing. Otherwise, it displays a message stating that the process
has terminated and modifies a flag so that the ExecutarProcesso function can modify the state of the process to "finished"
and return a value, stating that the allocated memory must be released.

* SIGQUIT and SIGINT
  These signals are received when the process is terminated by the terminal.
  
  The handler frees up all the allocated memory, as well as clearing the shared memory and displaying an end message.
	
